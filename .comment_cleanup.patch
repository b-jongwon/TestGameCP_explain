diff --git a/include/game.h b/include/game.h
index f9b6ccc..d71e1b2 100644
--- a/include/game.h
+++ b/include/game.h
@@
-#ifndef GAME_H // game.h 중복 include 방지용 include guard 시작
+#ifndef GAME_H // game.h 중복 include 방지용 include guard 시작
 #define GAME_H
 
-#define MAX_X 255             // 게임 맵의 가로 길이(열 수).
-#define MAX_Y 100             // 게임 맵의 세로 길이(행 수).
-#define SUBPIXELS_PER_TILE 10 // 1프레임당 이동거리
-#define PLAYER_MOVE_STEP_SUBPIXELS 2
-#define CONSTANT_PROJECTILE_RANGE 10 // 투사체 사거리
-#define SUPPLY_REFILL_AMOUNT 5       // 추가 되는 탄약 수
-#define MAX_OBSTACLES 64             // 한 스테이지에서 허용하는 최대 장애물 개수.
-#define MAX_ITEMS 32                 // 한 스테이지에 배치 가능한 최대 아이템 개수
-#define MAX_PROJECTILES 64           // 한 스테이지에서 동시에 존재할 수 있는 최대 투사체 개수
-#define MAX_PROFESSOR_CLONES 48      // 교수 패턴에서 동시에 관리할 수 있는 최대 분신 수
-#define MAX_PASSABLE_TILES (MAX_X * MAX_Y)
-#define MAX_PROFESSOR_CLONES 48      // 교수 패턴에서 동시에 관리할 수 있는 분신 수
-#define MAX_PROFESSOR_BULLETS 32     // 교수 스킬 탄환 동시 관리 수
+// -----------------------------------------------------------------------------
+// 전역 게임 설정 (Global Game Constants)
+// -----------------------------------------------------------------------------
+// 좌표계: 타일(Tile) 단위 맵 위에서 플레이어/오브젝트는 서브픽셀(Subpixel) 단위로 이동한다.
+// - 타일 좌표 -> 월드 좌표: tile * SUBPIXELS_PER_TILE
+// - 충돌/이동은 정수 기반으로 처리해 재현성(Determinism)을 높인다.
+
+#define MAX_X 255 // 맵 최대 가로(열) 길이
+#define MAX_Y 100 // 맵 최대 세로(행) 길이
+
+#define SUBPIXELS_PER_TILE 10        // 1타일을 몇 단위로 쪼갤지 (이동/충돌 정밀도)
+#define PLAYER_MOVE_STEP_SUBPIXELS 2 // 입력 1회당 목표 이동량(서브픽셀)
+
+#define CONSTANT_PROJECTILE_RANGE 10 // 투사체 사거리(타일 단위)
+#define SUPPLY_REFILL_AMOUNT 5       // 탄약 보충 아이템 1회당 증가량
+
+#define MAX_OBSTACLES 64             // 스테이지당 최대 장애물 수
+#define MAX_ITEMS 32                 // 스테이지당 최대 아이템 수
+#define MAX_PROJECTILES 64           // 동시 존재 가능한 최대 투사체 수
+#define MAX_PROFESSOR_CLONES 48      // 교수 패턴 분신 최대 수
+#define MAX_PROFESSOR_BULLETS 32     // 교수 탄환 최대 수
+#define MAX_PASSABLE_TILES (MAX_X * MAX_Y)
@@
-// Stage 구조체
-// - 한 스테이지에 대한 거의 모든 정보를 담는 구조체.
-// - 스테이지 ID, 이름, 맵 데이터, 시작/목표 위치, 장애물 목록 등을 포함.
+// Stage 구조체: 한 스테이지의 런타임 상태를 보관한다.
+// - 로딩 시 map/render_map/오브젝트 목록을 채우고, 게임 루프에서 지속 갱신한다.
 typedef struct
 {
@@
-// 벽 검사 함수
+// 타일 특성 판정(벽/통과 불가). stage.c 등에서 공용으로 사용한다.
 static inline int is_tile_opaque_char(char cell)
 {
     return (cell == '#' || cell == '@');
 }
@@
-#endif // GAME_H
+#endif // GAME_H
diff --git a/include/professor_pattern.h b/include/professor_pattern.h
index 6484cd5..2b94c1d 100644
--- a/include/professor_pattern.h
+++ b/include/professor_pattern.h
@@
 #ifndef PROFESSOR_PATTERNS_H
 #define PROFESSOR_PATTERNS_H
 
 #include "../include/game.h"
+
+// 교수(보스) 패턴 업데이트 API.
+// - 스테이지별 패턴은 Obstacle의 내부 상태(p_state/p_timer/p_misc 등)를 사용해 상태머신(State Machine)으로 동작한다.
+// - 탄환/분신 같은 엔티티는 Stage 내부 배열로 관리해 메모리 할당 없이 반복 실행 가능하도록 설계한다.
 
 typedef enum
 {
     PROFESSOR_BULLET_RESULT_NONE = 0,
     PROFESSOR_BULLET_RESULT_SHIELD_BLOCKED,
     PROFESSOR_BULLET_RESULT_FATAL
 } ProfessorBulletResult;
-
-
-
-
-int pattern_stage_1(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-int pattern_stage_2(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-
-int pattern_stage_3(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-int pattern_stage_4(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-int pattern_stage_5(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-int pattern_stage_6(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
-
-
-int update_professor_pattern(Stage *stage, Obstacle *prof,  Player *player, double delta_time);
+
+int pattern_stage_1(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+int pattern_stage_2(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+int pattern_stage_3(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+int pattern_stage_4(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+int pattern_stage_5(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+int pattern_stage_6(Stage *stage, Obstacle *prof, Player *player, double delta_time);
 
-ProfessorBulletResult update_professor_bullets(Stage *stage, Player *player, double delta_time);
+int update_professor_pattern(Stage *stage, Obstacle *prof, Player *player, double delta_time);
+ProfessorBulletResult update_professor_bullets(Stage *stage, Player *player, double delta_time);
 
-#endif 
+#endif // PROFESSOR_PATTERNS_H
diff --git a/include/input.h b/include/input.h
index 891f5c5..b5d3c89 100644
--- a/include/input.h
+++ b/include/input.h
@@
 #ifndef INPUT_H
 #define INPUT_H
 
-
-
+// SDL 이벤트를 게임 입력으로 정규화한다.
+// - 이동 입력은 "가장 마지막에 눌린 방향"을 우선한다(연속 이동 시 조작성 개선).
+// - read_input()은 이벤트 기반(한 번성 입력), current_direction_key()는 상태 기반(폴링)이다.
 void init_input(void);
-
-
 void restore_input(void);
-
-
 int read_input(void);
-
 int poll_input(void); 
-
 int current_direction_key(void);
 
-#endif 
+#endif // INPUT_H
diff --git a/include/collision.h b/include/collision.h
index fda51a5..11ce1a6 100644
--- a/include/collision.h
+++ b/include/collision.h
@@
 #ifndef COLLISION_H
 #define COLLISION_H
 
 #include "game.h"
+
+// 월드 좌표 기반 충돌 판정 유틸.
+// - 플레이어는 1타일 크기(=SUBPIXELS_PER_TILE 정사각형)로 가정한다.
+// - info를 전달하면 어느 방향으로 얼마나 겹쳤는지(해소용)까지 계산한다.
 
 typedef struct
 {
@@
 int is_world_position_blocked(const Stage *stage, int world_x, int world_y, CollisionInfo *info);
 
 int is_active_breakable_wall_at(const Stage *stage, int tx, int ty);
 
-#endif 
+#endif // COLLISION_H
diff --git a/include/player.h b/include/player.h
index f4712af..ee57f8b 100644
--- a/include/player.h
+++ b/include/player.h
@@
 #ifndef PLAYER_H
 #define PLAYER_H
 
 #include "../include/game.h"   
 #include "../include/stage.h"  
 
-
+// 플레이어 이동/애니메이션 갱신.
+// - move_player()는 입력을 "목표 좌표"로 변환하고, update_player_motion()이 delta_time 기반으로 실제 이동을 수행한다.
 void init_player(Player *p, const Stage *stage);
 
 void move_player(Player *p, char input, const Stage *stage, double current_time);
@@
 extern int g_player_anim_stride_pixels;
 
 #endif // PLAYER_H
diff --git a/include/sound.h b/include/sound.h
index 55b1a0b..83d9d95 100644
--- a/include/sound.h
+++ b/include/sound.h
@@
 #ifndef SOUND_H
 #define SOUND_H
@@
-// 사운드 워커, 캐시 등을 초기화 (게임 시작 시 1회 호출 권장)
+// 사운드 워커/캐시 등을 초기화(게임 시작 시 1회 호출 권장).
 void init_sound_system(void);
@@
-void stop_bgm();
+void stop_bgm(void);
@@
 void play_obstacle_caught_sound(const char *filePath);
 
 #endif // SOUND_H
diff --git a/src/sound.c b/src/sound.c
index 8f97b1c..c09f0c4 100644
--- a/src/sound.c
+++ b/src/sound.c
@@
 #include <SDL2/SDL.h>
@@
 #include <stdint.h>
 
 #include "sound.h"
 
-// 백그라운드 BGM 프로세스의 PID를 저장할 전역 변수
+// 사운드 시스템 설계 요약
+// - 효과음(SFX)은 SDL 오디오 디바이스를 열어 콜백에서 믹싱한다.
+// - 게임 루프를 막지 않기 위해 SFX 재생은 별도 워커 프로세스(fork)로 위임하고, 부모는 파이프로 명령만 전달한다.
+// - BGM은 외부 플레이어(aplay/say/espeak 등) 기반 구현(환경 의존)을 유지하되, 명령 가용성은 1회만 검사해 캐시한다.
+
+// 백그라운드 BGM 프로세스 PID
 static pid_t bgm_pid = -1;
 static int aplay_available = -1;
 static int espeak_available = -1;
-static int say_available = -1; // ✅ [추가] macOS 'say' 명령어의 가용성 캐시
+static int say_available = -1; // macOS 'say' 명령어의 가용성 캐시
 static pid_t g_sound_worker_pid = -1;
 static int g_sound_pipe[2] = {-1, -1};
 static int g_sound_worker_started = 0;
 static SDL_AudioDeviceID g_sound_device = 0;
@@
 static int command_exists_in_path(const char *cmd)
 {
@@
 }
@@
 static int write_full(int fd, const void *buf, size_t len)
 {
@@
 }
@@
 static int read_full(int fd, void *buf, size_t len)
 {
@@
 }
diff --git a/src/professor_pattern.c b/src/professor_pattern.c
index dd72460..1b55f76 100644
--- a/src/professor_pattern.c
+++ b/src/professor_pattern.c
@@
-// src/professor_patterns.c
+// professor_pattern.c
+// - 스테이지별 보스(교수) 패턴 상태머신 및 투사체/분신 업데이트를 담당한다.
+// - Stage 내부 고정 배열을 사용해 런타임 할당 없이 반복 실행 가능하도록 구성한다.
 
 #include "../include/professor_pattern.h"
@@
 static const int kStage3SoundPlayedFlag = 1 << 30;
 static const int kStage3MiscTimerMask = (1 << 30) - 1;
@@
 static int spawn_professor_clones(Stage *stage, const Player *player, const Obstacle *prof,
                                   int desired_count, double ttl)
 {
@@
-    short candidate_indices[MAX_PASSABLE_TILES];
+    // passable_tiles는 stage 로딩 시 1회 캐시된다.
+    // 여기서는 해당 풀(pool)에서 "플레이어/장애물/아이템/기존 분신"과 겹치지 않는 타일만 후보로 필터링한다.
+    short candidate_indices[MAX_PASSABLE_TILES];
     int available = 0;
diff --git a/src/player.c b/src/player.c
index 7dbd13f..5cf0f5b 100644
--- a/src/player.c
+++ b/src/player.c
@@
 #include <math.h>
 #include <stdlib.h>
 
 #include "../include/player.h"
 #include "../include/collision.h"
 
-
+// player.c
+// - 입력을 "목표 좌표"로 번역하고, delta_time 기반으로 실제 이동을 적분(integrate)한다.
+// - 월드 좌표는 서브픽셀 정수이므로, 프레임레이트가 달라도 이동 결과가 안정적으로 유지된다.
+
 int g_player_anim_stride_pixels = 4;
@@
 static void set_idle_animation(Player *p)
 {
     if (!p)
         return;
     p->anim_phase = PLAYER_ANIM_PHASE_IDLE_A;
     p->anim_pixel_progress = 0;
 }
 
-void init_player(Player *p, const Stage *stage) {
+void init_player(Player *p, const Stage *stage)
+{
+    // 난이도 설정값(stage->difficulty_player_speed)은 "타일당 걸리는 시간(초)"이다.
+    // move_speed는 "초당 서브픽셀"이므로 역수 변환이 필요하다.
     p->world_x = stage->start_x * SUBPIXELS_PER_TILE;
     p->world_y = stage->start_y * SUBPIXELS_PER_TILE;
     p->target_world_x = p->world_x;
     p->target_world_y = p->world_y;
-
-    
+
     double speed_setting = (stage->difficulty_player_speed > 0.0) ? stage->difficulty_player_speed : 0.18;
     p->base_move_speed = SUBPIXELS_PER_TILE / speed_setting;
     p->speed_multiplier = 1.0;
     p->move_speed = p->base_move_speed * p->speed_multiplier;
-    
+
     p->move_accumulator = 0.0;
     p->moving = 0;
     p->alive = 1;
@@
     p->is_moving = 0;
     p->last_move_time = 0.0;
-    p->shield_count = 0; 
+    p->shield_count = 0;
 }
@@
-void update_player_idle(Player *p, double current_time) {
-    if (!p) return;
+void update_player_idle(Player *p, double current_time)
+{
+    if (!p)
+        return;
@@
-    if (p->is_moving && current_time - p->last_move_time >= 0.5) {
+    if (p->is_moving && current_time - p->last_move_time >= 0.5)
+    {
         p->is_moving = 0;
         set_idle_animation(p);
     }
 }
